import { pascal, snake } from 'case';
import {
  Method,
  Parameter,
  Service,
  ReturnType,
  isRequired,
  Property,
} from '../types';

const tabSize = 2;

export function prefix(indent: number) {
  return ' '.repeat(indent * tabSize);
}

export function buildModuleNamespace(service: Service): string {
  return `${pascal(service.title)}::V${service.majorVersion}`;
}

export function buildNamespacedPath(service: Service): string[] {
  return [snake(service.title), `v${service.majorVersion}`];
}

export function* preamble(): Iterable<string> {
  yield `# This code was generated by a tool.`;
  yield `# ${require('../../package.json').name}@${
    require('../../package.json').version
  }`;
  yield `#`;
  yield `# Changes to this file may cause incorrect behavior and will be lost if`;
  yield `# the code is regenerated.`;
  yield ``;
  yield '# typed: strict';
  yield '';
  yield "require 'typed_struct_helper'";
  yield '';
}

export function buildTypeName(
  type: Parameter | Property | ReturnType,
  moduleNamespace: string,
  skipArrayify: boolean = false,
): string {
  const arrayify = (n: string) =>
    type.isArray && !skipArrayify ? `T::Array[${n}]` : n;

  if (type.isUnknown) {
    return arrayify('T.untyped');
  } else if (type.isLocal) {
    return arrayify(`${moduleNamespace}::${pascal(type.typeName)}`);
  }

  switch (type.typeName) {
    case 'string':
      return arrayify('String');
    case 'number':
      return arrayify('Numeric');
    case 'integer':
      return arrayify('Integer');
    case 'boolean':
      return arrayify('T::Boolean');
    default:
      return arrayify('T.untyped');
  }
}

export function* buildSignature(
  method: Method,
  service: Service,
  mode: 'abstract' | 'override' | 'none',
  indent: number,
): Iterable<string> {
  yield `${prefix(indent)}sig do`;
  if (method.returnType) {
    if (method.parameters.length) {
      yield* buildParamsWithReturnSignature(
        method.parameters,
        method.returnType,
        service,
        mode,
        indent + 1,
      );
    } else {
      yield* buildReturnSignature(method.returnType, service, mode, indent + 1);
    }
  } else {
    if (method.parameters.length) {
      yield* buildParamsVoidSignature(
        method.parameters,
        service,
        mode,
        indent + 1,
      );
    } else {
      yield* buildVoidSignature(mode, indent + 1);
    }
  }
  yield `${prefix(indent)}end`;
}

function* buildVoidSignature(
  mode: 'abstract' | 'override' | 'none',
  indent: number,
): Iterable<string> {
  yield `${prefix(indent)}${mode === 'none' ? '' : `${mode}.`}void`;
}

function* buildReturnSignature(
  returnType: ReturnType,
  service: Service,
  mode: 'abstract' | 'override' | 'none',
  indent: number,
): Iterable<string> {
  yield `${prefix(indent)}${
    mode === 'none' ? '' : `${mode}.`
  }returns(${buildTypeName(returnType, buildModuleNamespace(service))})`;
}

function* buildParamsVoidSignature(
  parameters: Parameter[],
  service: Service,
  mode: 'abstract' | 'override' | 'none',
  indent: number,
): Iterable<string> {
  const sortedParams = [
    ...parameters.filter((p) => isRequired(p)),
    ...parameters.filter((p) => !isRequired(p)),
  ];

  const params = sortedParams
    .map(
      (p) =>
        `${snake(p.name)}: ${
          isRequired(p)
            ? buildTypeName(p, buildModuleNamespace(service))
            : `T.nilable(${buildTypeName(p, buildModuleNamespace(service))})`
        }`,
    )
    .join(', ');

  yield `${prefix(indent)}${
    mode === 'none' ? '' : `${mode}.`
  }params(${params}).`;
  yield `${prefix(indent + 1)}void`;
}

function* buildParamsWithReturnSignature(
  parameters: Parameter[],
  returnType: ReturnType,
  service: Service,
  mode: 'abstract' | 'override' | 'none',
  indent: number,
): Iterable<string> {
  const sortedParams = [
    ...parameters.filter((p) => isRequired(p)),
    ...parameters.filter((p) => !isRequired(p)),
  ];

  const params = sortedParams
    .map(
      (p) =>
        `${snake(p.name)}: ${
          isRequired(p)
            ? buildTypeName(p, buildModuleNamespace(service))
            : `T.nilable(${buildTypeName(p, buildModuleNamespace(service))})`
        }`,
    )
    .join(', ');

  yield `${prefix(indent)}${
    mode === 'none' ? '' : `${mode}.`
  }params(${params}).`;
  yield `${prefix(indent + 1)}returns(${buildTypeName(
    returnType,
    buildModuleNamespace(service),
  )})`;
}

export function buildMethodParams(method: Method): string {
  if (!method.parameters.length) return '';

  const sortedParams = [
    ...method.parameters.filter((p) => isRequired(p)),
    ...method.parameters.filter((p) => !isRequired(p)),
  ];

  const paramString = sortedParams
    .map((p) => (isRequired(p) ? `${snake(p.name)}:` : `${snake(p.name)}: nil`))
    .join(', ');

  return `(${paramString})`;
}
